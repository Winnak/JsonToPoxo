/**
 * The Converter signature
 * See convertToX(string, Converter) for usage.
 * 
 * Converters convert an object into another language with the provided options.
 * If the options are not specified it should be able to create its own default.
 */
type Converter = (json: Object | Object[], options?: ConverterOptions) => string;

/**
 * General options for all the converters.
 */
interface ConverterOptions {
    varNameConversion(varName: string): string;
    indentation: string;
}

/**
 * Options for the CSharp converter.
 */
interface CSharpConverterOptions extends ConverterOptions {
    namespace: string,

    /**
     * Either properties or fields
     */
    useProperties: boolean,

    /**
     * e.g. "double", "float", "decimal"
     */
    floatType: string,

    /**
     * e.g. "[JsonProperty(\"`${key}`\")]"
     */
    jsonProperty: (key: string) => null | string
}

/**
 * Converts a JSON-string into a javascript object and parses it with the
 * specified converter.
 * @param text JSON-string
 * @param x Converter function
 */
function convertToX(text: string, x: Converter): string {
    let json;
    try {
        json = JSON.parse(text);
    } catch (error) {
        console.error(error.message);
        return error;
    }
    return x(json);
}

/**
 * Creates default options for CSharp converter.
 * See convertToCSharp(Object|Object[], CSharpConverterOptions)
 */
function createDefaultCSharpOptions(): CSharpConverterOptions {
    return <CSharpConverterOptions> {
        varNameConversion: s => pascalCase(sanitizeVariableName(s), false),
        indentation: "    ",
        useProperties: true,
        namespace: "YourNamespace",
        floatType: "double",
        jsonProperty: key => `[JsonProperty("${key}")]`
    };
}

/**
 * Converts a JSON object into CSharp code.
 * @param json
 * @param options
 */
function convertToCSharp(json: Object | Object[], options?: CSharpConverterOptions): string {
    if (options == undefined || options == null) {
        options = createDefaultCSharpOptions();
    }

    if (Array.isArray(json)) {
        if (json.length == 0) {
            return "Unable to determine type of empty array";
        }

        json = json[0];
    }
    const o = ( < CSharpConverterOptions > options);

    let result = "";
    let recursiveObjects: [string, object][] = [
        ["Poxo", json]
    ];
    while (recursiveObjects.length > 0) {
        const element = recursiveObjects.pop();
        if (element == undefined) {
            break;
        }

        const [objName, objVal]: [string, object] = element;
        const entries = Object.entries(objVal);
        result += entries.reduce((acc, [key, val]) => {
            const varName = o.varNameConversion(key);
            const varType = getCSharpTypeString([key, val], o);
            if (varType[1] != null) {
                recursiveObjects.push(varType[1]);
            }
            const epilogue = o.useProperties ? "{ get; set; }" : ";";
            let prelude = `\n${o.indentation + o.indentation}public `;
            if (o.jsonProperty != null) {
                prelude = `\n\n${o.indentation + o.indentation}${o.jsonProperty(key)}` + prelude;
            }
            return acc + `${prelude}${varType[0]} ${varName} ${epilogue}`;
        }, `\n${o.indentation}public class ${objName}\n${o.indentation}{`) + `\n${o.indentation}}`;
    }

    return `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a JsonToPoxo.
// </auto-generated>
//------------------------------------------------------------------------------
using Newtonsoft.Json;

namespace ${o.namespace}
{${result}
}`;
}

/**
 * Gets the corresponding C# type of the JSON value.
 * @param param0 the json key value pair.
 * @param options the options for the language.
 */
function getCSharpTypeString([varName, varType]: [string, any], options: CSharpConverterOptions): [string, [string, object] | null] {
    const type = typeof varType;
    switch (type) {
        case "string":
            return ["string", null]
        case "number":
            if (Number.isInteger(varType)) {
                return ["int", null];
            }
            return [options.floatType, null];
        case "bigint":
            return ["System.Numerics.BigInteger", null]
        case "boolean":
            return ["bool", null]

        case "object":
            if (varType == null) {
                return ["object /* unable to determine */", null];
            }
            if (Array.isArray(varType)) {
                if (varType.length > 0) {
                    // TODO: Check if the data is uniform.
                    const arrayType = getCSharpTypeString([varName, varType[0]], options);
                    return [arrayType[0] + "[]", arrayType[1]];
                }
                return ["object[]", null]
            }
            if (Object.entries(varType).length > 0) {
                const newType = options.varNameConversion(varName)
                return [newType, [newType, varType]];
            }

            return ["object", null]
        default:
        case "symbol":
        case "undefined":
            return ["object /* unknown type */", null]
        case "function":
            return ["object /* unable to convert function */", null]
    }
}

/**
 * Removes any non ASCII alphanumeric character into an underscore.
 * and prepends a v if it starts with a numeric character.
 * @param varName 
 */
function sanitizeVariableName(varName: string): string {
    varName = varName.replace(/(?![\x30-\x39\x41-\x5a\x61-\x7a])./gu, "_");
    if (varName.length == 0 || !isNaN(parseInt(varName[0], 10))) {
        return "v" + varName;
    }
    return varName;
}

/**
 * Converts the first letter to uppercase
 * @param s
 */
function capitalize(s: string): string {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Converts a variable name to PascalCasing
 * @param someString string to be converted
 * @param capitalizeAbbreviations e.g. if true: 'URL' otherwise "Url"
 */
function pascalCase(someString: string, capitalizeAbbreviations: boolean = false): string {

    // e.g. UPPER_CASE_123 -> upper_case_123
    if (someString.match(/^[A-Z_0-9]+$/g)) {
        someString = someString.toLowerCase();
    } else if (!capitalizeAbbreviations) {
        someString = someString
            // BARThing -> BarThing
            .replace(/([A-Z])([A-Z]+)([A-Z][a-z])/g,
                (_m, p1, p2, p3, _o, _s) => p1 + p2.toLowerCase() + p3)

            // fooBAR -> fooBar
            .replace(/([A-Z])([A-Z]+)/g,
                (_m, p1, p2, _o, _s) => p1 + p2.toLowerCase())
    }

    // e.g. barSome__Foo_thing_ -> BarSomeFooThing
    someString = someString.replace(/_+(.)|^([a-z])/g, (match, p1, p2, _o, _s) =>
        p1 ? capitalize(p1) :
        p2 ? capitalize(p2) :
        match);

    return someString;
}